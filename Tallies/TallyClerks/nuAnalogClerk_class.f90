module nuAnalogClerk_class

  use numPrecision
  use tallyCodes
  use endfConstants
  use dictionary_class,      only : dictionary
  use particle_class,        only : particle, particleState, P_PRECURSOR, P_NEUTRON
  use particleDungeon_class, only : particleDungeon
  use outputFile_class,      only : outputFile

  use scoreMemory_class,     only : scoreMemory
  use tallyClerk_inter,      only : tallyClerk, kill_super => kill

  ! Tally Maps
  use tallyMap_inter,        only : tallyMap
  use tallyMapFactory_func,  only : new_tallyMap

  ! Nuclear Data Interfaces
  use nuclearDatabase_inter, only : nuclearDatabase

  implicit none
  private

  !! Locations of diffrent bins wrt memory address of the clerk
  integer(shortInt), parameter :: MEM_SIZE = 2
  integer(longInt), parameter  :: NU_FISS  = 0, &  ! Number of neutrons generated by fission
                                  EVENT    = 1     ! Number of events

  !!
  !! Analog estimator for nu prompt or delayed
  !!
  !! Private Members:
  !!   delayed -> flag that indicated whether nu prompt or nu delayed is requested
  !!
  !! SAMPLE DICTIOANRY INPUT:
  !!
  !! myClerk {
  !!   type nuAnalogClerk;
  !!   #delayed = 1;#
  !!   #batches 20000;#
  !!   #map { <tallyMap definition> }#
  !! }
  !!
  !! NOTE: when results are integrated over all time steps, batches has to be provided
  !! otherwise the STD is NaN. Batches needs to be cycles * timeSteps
  !!
  type, public,extends(tallyClerk) :: nuAnalogClerk
    private
    integer(shortInt) :: batches = 0
    logical(defBool)  :: delayed = .false.
    class(tallyMap), allocatable :: map
  contains
    ! Procedures used during build
    procedure :: init
    procedure :: kill
    procedure :: validReports
    procedure :: getSize

    ! File reports and check status -> run-time procedures
    procedure :: reportSpawn
    procedure :: reportOutColl

    ! Output procedures
    procedure  :: display
    procedure  :: print

  end type nuAnalogClerk

contains

  !!
  !! Initialise from dictionary and name
  !!
  !! See tallyClerk_inter for details
  !!
  subroutine init(self, dict, name)
    class(nuAnalogClerk), intent(inout) :: self
    class(dictionary), intent(in)       :: dict
    character(nameLen), intent(in)      :: name

    ! Needs no settings, just load name
    call self % setName(name)

    ! User provided number of batches to get accurate std
    call dict % getOrDefault(self % batches, 'batches', 0)

    ! Initialise delayed flag
    call dict % getOrDefault(self % delayed, 'delayed', .false.)

    ! Load map
    if (dict % isPresent('map')) then
      call new_tallyMap(self % map, dict % getDictPtr('map'))
    end if

  end subroutine init

  !!
  !! Return to uninitialised state
  !!
  elemental subroutine kill(self)
    class(nuAnalogClerk), intent(inout) :: self

    ! Superclass
    call kill_super(self)

    ! Kill and deallocate map
    if (allocated(self % map)) then
      call self % map % kill()
      deallocate(self % map)
    end if

    self % batches = 0
    self % delayed = .false.

  end subroutine kill

  !!
  !! Returns array of codes that represent diffrent reports
  !!
  !! See tallyClerk_inter for details
  !!
  function validReports(self) result(validCodes)
    class(nuAnalogClerk),intent(in)            :: self
    integer(shortInt),dimension(:),allocatable :: validCodes

    validCodes = [ spawn_CODE, outColl_CODE ]

  end function validReports

  !!
  !! Return memory size of the clerk
  !!
  !! See tallyClerk_inter for details
  !!
  elemental function getSize(self) result(S)
    class(nuAnalogClerk), intent(in) :: self
    integer(shortInt)                :: S

    S = MEM_SIZE
    if (allocated(self % map)) S = S * self % map % bins(0)

  end function getSize

  !!
  !! Process fission report
  !!
  !! See tallyClerk_inter for details
  !!
  subroutine reportSpawn(self, MT, pOld, pNew, xsData, mem)
    class(nuAnalogClerk), intent(inout)   :: self
    integer(shortInt), intent(in)         :: MT
    class(particle), intent(in)           :: pOld
    class(particleState), intent(in)      :: pNew
    class(nuclearDatabase), intent(inout) :: xsData
    type(scoreMemory), intent(inout)      :: mem
    type(particleState)                   :: state
    integer(shortInt)                     :: binIdx
    integer(longInt)                      :: addr
    real(defReal)                         :: newScore

    if (MT == N_FISSION) then
    ! Get current particle state
    state = pOld
    newScore = ZERO
    
    ! Set state to account for delayed/prompt production
    if (self % delayed .and. pNew % type == P_PRECURSOR) then
      state % F = pNew % F
      state % lambda = pNew % lambda
      state % type = pNew % type
      newScore = ONE
    else if (.not. self % delayed .and. pNew % type == P_NEUTRON) then
      newScore = ONE
    else 
      return
    end if

    ! Find bin index 
    if (allocated(self % map)) then
      binIdx = self % map % map(state)
    else
      binIdx = 1
    end if
    ! Return if invalid bin index
    if (binIdx == 0) return

    ! Calculate bin address
    addr = self % getMemAddress() + MEM_SIZE * (binIdx - 1)

    if ((self % delayed .and. pNew % type == P_PRECURSOR) .or. &
        & (.not. self % delayed .and. pNew % type == P_NEUTRON)) then

      ! Score nu
      call mem % score(newScore, addr + NU_FISS)

    end if
  end if

  end subroutine reportSpawn

  !!
  !! Process outgoing collision report
  !!
  !! See tallyClerk_inter for details
  !!
  subroutine reportOutColl(self, p, MT, muL, xsData, mem)
    class(nuAnalogClerk), intent(inout)  :: self
    class(particle), intent(in)          :: p
    integer(shortInt), intent(in)        :: MT
    real(defReal), intent(in)            :: muL
    class(nuclearDatabase),intent(inout) :: xsData
    type(scoreMemory), intent(inout)     :: mem
    type(particleState)                  :: state
    integer(shortInt)                    :: binIdx
    integer(longInt)                     :: addr

    ! Score analog event if a fission happened
    if (MT == N_FISSION) then

      ! Get current particle state
      state = p

      ! Find bin index
      if (allocated(self % map)) then
        binIdx = self % map % map(state)
      else
        binIdx = 1
      end if

      ! Return if invalid bin index
      if (binIdx == 0) return

      ! Calculate bin address
      addr = self % getMemAddress() + MEM_SIZE * (binIdx - 1)

      call mem % score(ONE, addr + EVENT)

    end if

  end subroutine reportOutColl

  !!
  !! Display convergance progress on the console
  !!
  !! See tallyClerk_inter for details
  !!
  subroutine display(self, mem)
    class(nuAnalogClerk), intent(in)  :: self
    type(scoreMemory), intent(in)     :: mem

    ! Does nothing

  end subroutine display

  !!
  !! Write contents of the clerk in the slot to output file
  !!
  !! See tallyClerk_inter for details
  !!
  subroutine print(self, outFile, mem)
    class(nuAnalogClerk), intent(in) :: self
    class(outputFile), intent(inout) :: outFile
    type(scoreMemory), intent(in)    :: mem
    real(defReal)                    :: nu, events, nu_score, STD, STDnu, STDevents
    character(nameLen)               :: name
    integer(shortInt)                :: i
    integer(longInt)                 :: addr
    integer(shortInt),dimension(:),allocatable :: resArrayShape

    ! Print to output file
    call outFile % startBlock(self % getName())

    ! Print out map info
    if (allocated(self % map)) then
      call self % map % print(outFile)
      resArrayShape = self % map % binArrayShape()
    else
      resArrayShape = [1]
    end if

    name = 'Res'

    call outFile % startArray(name, resArrayShape)

    ! Print results to the file
    do i = 1, product(resArrayShape)

      addr = self % getMemAddress() + MEM_SIZE * (i - 1)

      ! NOTE: In time dependent calculations, when results are integrated over all time,
      ! the number of batches used to average the results is the number of cycles
      ! times the number of time steps. This must be provided by the user otherwise
      ! the STD will be NaN
      if (self % batches /= 0) then
        call mem % getResult(nu, STDnu, addr + NU_FISS, self % batches)
        call mem % getResult(events, STDevents, addr + EVENT, self % batches)
      else
        call mem % getResult(nu, STDnu, addr + NU_FISS)
        call mem % getResult(events, STDevents, addr + EVENT)
      end if

      nu_score = nu/events
      STD = nu_score * sqrt((STDnu/nu)**2 + (STDevents/events)**2)

      call outFile % addResult(nu_score, STD)

    end do

    call outFile % endArray()

    call outFile % endBlock()

  end subroutine print

end module nuAnalogClerk_class
